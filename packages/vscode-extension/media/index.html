<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cairn Task List</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      background-color: var(--vscode-sideBar-background);
      color: var(--vscode-foreground);
      margin: 0;
      padding: 20px;
      padding-bottom: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      box-sizing: border-box;
    }

    h1 {
      color: #D4A556;
      font-size: 24px;
      margin: 0 0 20px 0;
    }

    .header {
      margin-bottom: 20px;
    }

    /* Filter Bar Styles */
    .filter-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 16px;
      padding: 8px 0;
      font-size: 13px;
    }

    .filter-icon {
      opacity: 0.5;
      font-size: 16px;
      margin-right: 2px;
      display: inline-flex;
      align-items: center;
    }

    .filter-icon svg {
      width: 16px;
      height: 16px;
    }

    .filter-trigger {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background-color: transparent;
      border: none;
      border-radius: 6px;
      color: var(--vscode-foreground);
      cursor: pointer;
      font-size: 13px;
      position: relative;
      transition: all 0.15s;
      font-weight: 400;
    }

    .filter-trigger:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .filter-trigger.active {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .filter-trigger-label {
      font-weight: 500;
      opacity: 0.9;
    }

    .filter-trigger-caret {
      opacity: 0.5;
      font-size: 10px;
      margin-left: 2px;
    }

    /* Filter Chips */
    .filter-chips {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .filter-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: default;
      transition: all 0.15s;
    }

    .filter-chip-icon {
      font-size: 14px;
      line-height: 1;
    }

    .filter-chip-close {
      cursor: pointer;
      opacity: 0.7;
      font-size: 16px;
      line-height: 1;
      padding: 0 0 0 4px;
      transition: opacity 0.15s;
    }

    .filter-chip-close:hover {
      opacity: 1;
    }

    /* Status-specific chip colors (muted versions) */
    .filter-chip.ready {
      background-color: rgba(212, 165, 86, 0.2);
      color: #D4A556;
    }

    .filter-chip.open {
      background-color: rgba(46, 160, 67, 0.2);
      color: #3fb950;
    }

    .filter-chip.in_progress {
      background-color: rgba(68, 131, 255, 0.2);
      color: #58a6ff;
    }

    .filter-chip.closed {
      background-color: rgba(139, 148, 158, 0.2);
      color: #8b949e;
    }

    .filter-chip.blocked {
      background-color: rgba(218, 54, 51, 0.2);
      color: #f85149;
    }

    /* Add Filter Button */
    .add-filter-btn {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 6px 10px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: #58a6ff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.15s;
    }

    .add-filter-btn:hover {
      background-color: rgba(88, 166, 255, 0.1);
    }

    .add-filter-btn-icon {
      font-size: 16px;
      line-height: 1;
    }

    /* Clear Filters Button */
    .clear-filters-btn {
      display: inline-flex;
      align-items: center;
      padding: 5px 10px;
      background: transparent;
      border: none;
      color: var(--vscode-foreground);
      cursor: pointer;
      font-size: 12px;
      opacity: 0.6;
      transition: opacity 0.15s;
      text-decoration: underline;
    }

    .clear-filters-btn:hover {
      opacity: 1;
    }

    /* Status Popover */
    .status-popover {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      min-width: 180px;
      background-color: var(--vscode-dropdown-background);
      border: 1px solid var(--vscode-dropdown-border);
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      padding: 6px 0;
      display: none;
    }

    .status-popover.visible {
      display: block;
    }

    .popover-header {
      padding: 8px 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      opacity: 0.6;
      letter-spacing: 0.5px;
    }

    .popover-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.1s;
    }

    .popover-option:hover {
      background-color: var(--vscode-list-hoverBackground);
    }

    .popover-checkbox {
      width: 14px;
      height: 14px;
      border: 1.5px solid var(--vscode-input-border);
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.15s;
    }

    .popover-checkbox.checked {
      background-color: var(--vscode-button-background);
      border-color: var(--vscode-button-background);
    }

    .popover-checkbox.checked::after {
      content: '‚úì';
      color: var(--vscode-button-foreground);
      font-size: 10px;
      font-weight: bold;
    }

    .popover-divider {
      height: 1px;
      background-color: var(--vscode-dropdown-border);
      margin: 4px 0;
    }

    .popover-action {
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
      opacity: 0.8;
      transition: all 0.1s;
    }

    .popover-action:hover {
      background-color: var(--vscode-list-hoverBackground);
      opacity: 1;
    }

    .task-grid {
      width: 100%;
      border-collapse: collapse;
      background-color: var(--vscode-editor-background);
    }

    #task-container {
      overflow: hidden;
      /* Prevent any overflow from this container */
    }

    .task-body-container {
      overflow-y: auto;
      border: 1px solid var(--vscode-panel-border);
      border-top: none;
      border-radius: 0 0 4px 4px;
      position: relative;
    }

    .task-grid-header {
      border: 1px solid var(--vscode-panel-border);
      border-bottom: none;
      border-radius: 4px 4px 0 0;
    }

    .task-grid-body {
      width: 100%;
      border-collapse: collapse;
      background-color: var(--vscode-editor-background);
    }

    .task-grid th {
      background-color: var(--vscode-editor-background);
      color: var(--vscode-foreground);
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      border-bottom: 1px solid var(--vscode-panel-border);
    }

    /* Column width distribution */
    .task-grid colgroup col:nth-child(1) {
      width: auto;
      /* Title - shares remaining space */
    }

    .task-grid colgroup col:nth-child(2) {
      width: auto;
      /* Description - shares remaining space */
    }

    .task-grid colgroup col:nth-child(3) {
      width: 120px;
      /* Status - fixed narrow width */
    }

    .task-grid colgroup col:nth-child(4) {
      width: 100px;
      /* Priority - fixed narrow width */
    }

    .task-grid colgroup col:nth-child(5) {
      width: 120px;
      /* Dependencies - fixed narrow width */
    }

    .task-grid colgroup col:nth-child(6) {
      width: 140px;
      /* Actions - fixed narrow width */
    }

    .task-grid td {
      padding: 12px 16px;
      vertical-align: top;
      position: relative;
    }

    /* Actions column uses middle alignment */
    .task-grid td:nth-child(6) {
      vertical-align: middle;
    }

    /* Make title and description cells share equally */
    .task-grid td:nth-child(1),
    .task-grid td:nth-child(2) {
      width: 50%;
    }

    /* Border on row, not individual cells */
    .task-row {
      border-bottom: 1px solid var(--vscode-panel-border);
    }

    .child-row {
      border-bottom: 1px solid var(--vscode-panel-border);
    }

    .hidden-children-row {
      border-bottom: 1px solid var(--vscode-panel-border);
    }

    .header-controls {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    .header-btn {
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--vscode-foreground);
      border: none;
      cursor: pointer;
      padding: 6px 12px;
      font-size: 13px;
      border-radius: 6px;
      font-weight: 400;
      transition: background-color 0.15s;
    }

    .create-new-issue-btn {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 6px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
    }

    .header-btn:hover {
      background-color: rgba(255, 255, 255, 0.08);
    }

    .task-row {
      transition: background-color 0.1s;
    }

    .task-row:hover {
      background-color: var(--vscode-list-hoverBackground);
    }

    .title-cell {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .expand-icon {
      cursor: pointer;
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--vscode-foreground);
      opacity: 0.7;
      flex-shrink: 0;
      margin-left: 1px;
    }

    .expand-icon:hover {
      opacity: 1;
    }

    .expand-icon.collapsed::before {
      content: '‚ñ∂';
      font-size: 10px;
    }

    .expand-icon.expanded::before {
      content: '‚ñº';
      font-size: 10px;
    }

    .expand-icon.empty {
      opacity: 0;
      cursor: default;
    }

    .type-badge {
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
      height: 22px;
      line-height: 1;
    }

    .type-badge::before {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      line-height: 1;
    }

    .type-badge.epic {
      background-color: rgba(138, 98, 255, 0.2);
      color: #8A62FF;
    }

    .type-badge.epic::before {
      content: '‚ö°';
    }

    .type-badge.task {
      background-color: rgba(68, 131, 255, 0.2);
      color: #4483FF;
    }

    .type-badge.task::before {
      content: '‚Ä¢';
      font-size: 16px;
    }

    .type-badge.bug {
      background-color: rgba(218, 54, 51, 0.2);
      color: #f85149;
    }

    .type-badge.bug::before {
      content: 'üêõ';
      font-size: 11px;
    }

    .type-badge.feature {
      background-color: rgba(46, 160, 67, 0.2);
      color: #3fb950;
    }

    .type-badge.feature::before {
      content: '‚ú®';
      font-size: 11px;
    }

    .type-badge.chore {
      background-color: rgba(139, 148, 158, 0.2);
      color: #8b949e;
    }

    .type-badge.chore::before {
      content: 'üîß';
      font-size: 11px;
    }

    .type-badge.docs {
      background-color: rgba(88, 166, 255, 0.2);
      color: #58a6ff;
    }

    .type-badge.docs::before {
      content: 'üìù';
      font-size: 11px;
    }

    .type-badge.refactor {
      background-color: rgba(212, 165, 86, 0.2);
      color: #D4A556;
    }

    .type-badge.refactor::before {
      content: '‚ôªÔ∏è';
      font-size: 11px;
    }

    .task-title-text {
      color: var(--vscode-editor-foreground);
    }

    .description-cell {
      max-width: 400px;
      position: relative;
    }

    .description-content {
      font-size: 12px;
      color: var(--vscode-descriptionForeground);
      line-height: 1.4;
    }

    .description-content.collapsed {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      cursor: pointer;
    }

    .description-content.collapsed:hover {
      color: var(--vscode-foreground);
    }

    .description-content.expanded {
      cursor: pointer;
    }

    .description-content.expanded h1,
    .description-content.expanded h2,
    .description-content.expanded h3 {
      margin: 8px 0 4px 0;
      color: var(--vscode-foreground);
    }

    .description-content.expanded h1 {
      font-size: 16px;
      font-weight: 600;
    }

    .description-content.expanded h2 {
      font-size: 14px;
      font-weight: 600;
    }

    .description-content.expanded h3 {
      font-size: 13px;
      font-weight: 600;
    }

    .description-content.expanded p {
      margin: 4px 0;
      line-height: 1.5;
    }

    .description-content.expanded ul,
    .description-content.expanded ol {
      margin: 4px 0;
      padding-left: 20px;
    }

    .description-content.expanded li {
      margin: 2px 0;
    }

    .description-content.expanded code {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: var(--vscode-editor-font-family);
      font-size: 0.9em;
    }

    .description-content.expanded pre {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 8px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 8px 0;
    }

    .description-content.expanded pre code {
      background: none;
      padding: 0;
    }

    .description-content.expanded strong {
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    .description-content.expanded em {
      font-style: italic;
    }

    .description-empty {
      opacity: 0.4;
      font-style: italic;
      font-size: 12px;
    }

    .pill {
      padding: 6px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
      display: inline-block;
      text-transform: capitalize;
    }

    .status-open {
      background-color: rgba(46, 160, 67, 0.2);
      color: #3fb950;
    }

    .status-in_progress {
      background-color: rgba(68, 131, 255, 0.2);
      color: #58a6ff;
    }

    .status-closed {
      background-color: rgba(139, 148, 158, 0.2);
      color: #8b949e;
    }

    .status-blocked {
      background-color: rgba(218, 54, 51, 0.2);
      color: #f85149;
    }

    .priority-low {
      background-color: rgba(46, 160, 67, 0.2);
      color: #3fb950;
    }

    .priority-medium {
      background-color: rgba(212, 165, 86, 0.2);
      color: #D4A556;
    }

    .priority-high {
      background-color: rgba(251, 133, 0, 0.2);
      color: #fb8500;
    }

    .priority-urgent {
      background-color: rgba(218, 54, 51, 0.2);
      color: #f85149;
    }

    .task-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-start;
      align-items: center;
      position: relative;
    }

    .kebab-menu-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px;
      border-radius: 3px;
      opacity: 0.7;
      transition: opacity 0.15s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--vscode-foreground);
      height: 28px;
      width: 28px;
      position: relative;
    }

    .kebab-menu-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.05);
    }

    .kebab-menu-btn.active {
      opacity: 1;
      background: rgba(255, 255, 255, 0.08);
    }

    .kebab-icon {
      display: flex;
      flex-direction: column;
      gap: 3px;
      align-items: center;
    }

    .kebab-icon span {
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background-color: currentColor;
    }

    .action-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 160px;
      background-color: var(--vscode-dropdown-background);
      border: 1px solid var(--vscode-dropdown-border);
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      padding: 4px 0;
      display: none;
      margin-top: 4px;
    }

    .action-dropdown.visible {
      display: block;
    }

    .action-dropdown-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.1s;
      color: var(--vscode-foreground);
    }

    .action-dropdown-item:hover {
      background-color: var(--vscode-list-hoverBackground);
    }

    .action-dropdown-item.danger {
      color: #f85149;
    }

    .action-dropdown-item.danger:hover {
      background-color: rgba(248, 81, 73, 0.1);
    }

    .action-dropdown-icon {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .action-dropdown-icon svg {
      width: 16px;
      height: 16px;
    }

    .action-dropdown-divider {
      height: 1px;
      background-color: var(--vscode-dropdown-border);
      margin: 4px 0;
    }

    .start-btn {
      background-color: #0969da;
      color: white;
      border: none;
      padding: 6px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
    }

    .start-btn:hover {
      background-color: #0860ca;
    }

    .complete-btn {
      background-color: #2ea043;
      color: white;
      border: none;
      padding: 6px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
    }

    .complete-btn:hover {
      background-color: #2c974b;
    }

    .edit-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px;
      border-radius: 3px;
      opacity: 0.7;
      transition: opacity 0.15s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--vscode-foreground);
      height: 28px;
      width: 28px;
    }

    .edit-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.05);
    }

    .edit-btn svg {
      width: 16px;
      height: 16px;
    }

    .delete-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px;
      border-radius: 3px;
      opacity: 0.7;
      transition: opacity 0.15s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #f85149;
      position: relative;
      height: 28px;
      width: 28px;
    }

    .delete-btn:hover {
      opacity: 1;
      background: rgba(248, 81, 73, 0.1);
    }

    .delete-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Delete Confirmation Popup */
    .delete-confirm-popup {
      position: absolute;
      background-color: var(--vscode-dropdown-background);
      border: 1px solid #f85149;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      padding: 12px;
      z-index: 2000;
      min-width: 220px;
      display: none;
    }

    .delete-confirm-popup.visible {
      display: block;
    }

    .delete-confirm-text {
      color: var(--vscode-foreground);
      font-size: 13px;
      margin-bottom: 12px;
      line-height: 1.4;
    }

    .delete-confirm-text strong {
      color: #f85149;
    }

    .delete-confirm-buttons {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .delete-confirm-btn {
      padding: 4px 12px;
      border: none;
      border-radius: 3px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.15s;
    }

    .delete-confirm-btn.delete {
      background-color: #f85149;
      color: white;
    }

    .delete-confirm-btn.delete:hover {
      background-color: #da3633;
    }

    .delete-confirm-btn.cancel {
      background-color: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
    }

    .delete-confirm-btn.cancel:hover {
      background-color: var(--vscode-button-secondaryHoverBackground);
    }

    .child-row {
      background-color: var(--vscode-editor-background);
    }

    .title-cell {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 100%;
    }

    .tree-lines-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      overflow: visible;
    }

    .tree-lines-svg path,
    .tree-lines-svg line {
      stroke: rgba(255, 255, 255, 0.15);
      stroke-width: 2;
      fill: none;
    }

    .hidden-children-row {
      background-color: var(--vscode-panel-border);
    }

    .header-single-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .hidden-children-indicator {
      color: var(--vscode-descriptionForeground);
      font-size: 12px;
      font-style: italic;
      margin-top: -8px;
      margin-bottom: -8px;
      opacity: 0.7;
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>Cairn Task List</h1>
  </div>
  <div class="filter-bar">
    <div class="filter-trigger" id="status-filter-trigger">
      <span class="filter-icon"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M19 3H5C3.58579 3 2.87868 3 2.43934 3.4122C2 3.8244 2 4.48782 2 5.81466V6.50448C2 7.54232 2 8.06124 2.2596 8.49142C2.5192 8.9216 2.99347 9.18858 3.94202 9.72255L6.85504 11.3624C7.49146 11.7206 7.80967 11.8998 8.03751 12.0976C8.51199 12.5095 8.80408 12.9935 8.93644 13.5872C9 13.8722 9 14.2058 9 14.8729L9 17.5424C9 18.452 9 18.9067 9.25192 19.2613C9.50385 19.6158 9.95128 19.7907 10.8462 20.1406C12.7248 20.875 13.6641 21.2422 14.3321 20.8244C15 20.4066 15 19.4519 15 17.5424V14.8729C15 14.2058 15 13.8722 15.0636 13.5872C15.1959 12.9935 15.488 12.5095 15.9625 12.0976C16.1903 11.8998 16.5085 11.7206 17.145 11.3624L20.058 9.72255C21.0065 9.18858 21.4808 8.9216 21.7404 8.49142C22 8.06124 22 7.54232 22 6.50448V5.81466C22 4.48782 22 3.8244 21.5607 3.4122C21.1213 3 20.4142 3 19 3Z"
            fill="currentColor"></path>
        </svg></span>
      <span class="filter-trigger-label">Status:</span>
      <div class="status-popover" id="status-popover">
        <div class="popover-header">Status</div>
        <div class="popover-option" data-status="ready">
          <div class="popover-checkbox"></div>
          <span>Ready</span>
        </div>
        <div class="popover-option" data-status="open">
          <div class="popover-checkbox"></div>
          <span>Open</span>
        </div>
        <div class="popover-option" data-status="in_progress">
          <div class="popover-checkbox"></div>
          <span>In Progress</span>
        </div>
        <div class="popover-option" data-status="closed">
          <div class="popover-checkbox"></div>
          <span>Closed</span>
        </div>
        <div class="popover-option" data-status="blocked">
          <div class="popover-checkbox"></div>
          <span>Blocked</span>
        </div>
        <div class="popover-divider"></div>
        <div class="popover-action" id="clear-status-selection">Clear</div>
      </div>
    </div>
    <div class="filter-chips" id="filter-chips"></div>
    <button class="clear-filters-btn" id="clear-all-filters" style="display: none;">Clear filters</button>
    <button class="add-filter-btn" id="add-filter-btn">
      <span class="add-filter-btn-icon">+</span>
      <span>Add Filter</span>
    </button>
  </div>
  <div id="task-container">
    <!-- Tasks will be populated here -->
  </div>

  <script>
    // Acquire VS Code API once at the beginning
    const vscode = acquireVsCodeApi();
    console.log('Cairn task list webview script loaded');

    const expandedTasks = new Set();
    const expandedDescriptions = new Set();
    let selectedStatuses = new Set(['ready']); // Default filter
    let isPopoverOpen = false;
    let allTasks = [];

    // Notify extension that webview is ready
    vscode.postMessage({ type: 'webviewReady' });
    console.log('Task list webview ready message sent');

    // Utility functions for creating pill components
    function createTypeBadge(type) {
      const badge = document.createElement('span');
      badge.className = `type-badge ${type || 'task'}`;
      badge.textContent = type || 'Task';
      return badge;
    }

    function createStatusPill(status, displayText = null) {
      const pill = document.createElement('span');
      const displayStatus = status || 'open';
      const text = displayText || (displayStatus === 'in_progress' ? 'In Progress' :
        (displayStatus.charAt(0).toUpperCase() + displayStatus.slice(1)));
      pill.className = `pill status-${displayStatus}`;
      pill.textContent = text;
      return pill;
    }

    function createPriorityPill(priority) {
      const pill = document.createElement('span');
      const displayPriority = priority || 'medium';
      pill.className = `pill priority-${displayPriority}`;
      pill.textContent = displayPriority.charAt(0).toUpperCase() + displayPriority.slice(1);
      return pill;
    }

    // Simple markdown to HTML converter
    function markdownToHtml(markdown) {
      let html = markdown;

      // Code blocks (before inline code)
      html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');

      // Headers
      html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
      html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
      html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');

      // Bold
      html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

      // Italic
      html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

      // Inline code
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

      // Unordered lists
      html = html.replace(/^- (.+)$/gim, '<li>$1</li>');
      html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');

      // Paragraphs (split by double newlines)
      const parts = html.split('\n\n');
      html = parts.map(part => {
        part = part.trim();
        if (!part) return '';
        if (part.startsWith('<h') || part.startsWith('<ul') || part.startsWith('<pre')) {
          return part;
        }
        return '<p>' + part.replace(/\n/g, '<br>') + '</p>';
      }).join('\n');

      return html;
    }

    // Function to check if a task is ready (no blocking dependencies)
    function isReady(task, allTasks) {
      if (!task.dependencies) return true;
      const taskMap = new Map(allTasks.map(t => [t.id, t]));
      return task.dependencies.every(dep => {
        if (dep.type !== 'blocks') return true;
        const depTask = taskMap.get(dep.id);
        return depTask && depTask.status === 'closed';
      });
    }

    // Function to check if a task is blocked
    function isBlocked(task, allTasks) {
      if (!task.dependencies || task.status === 'closed') return false;
      const taskMap = new Map(allTasks.map(t => [t.id, t]));
      return task.dependencies.some(dep => {
        if (dep.type !== 'blocks') return false;
        const depTask = taskMap.get(dep.id);
        return depTask && depTask.status !== 'closed';
      });
    }

    function toggleExpand(taskId) {
      if (expandedTasks.has(taskId)) {
        expandedTasks.delete(taskId);
      } else {
        expandedTasks.add(taskId);
      }
      renderTasks(allTasks);
    }

    function toggleDescription(taskId) {
      if (expandedDescriptions.has(taskId)) {
        expandedDescriptions.delete(taskId);
      } else {
        expandedDescriptions.add(taskId);
      }
      renderTasks(allTasks);
    }

    // Update filter chips display
    function updateFilterChips() {
      const chipsContainer = document.getElementById('filter-chips');
      const clearAllBtn = document.getElementById('clear-all-filters');
      const statusTrigger = document.getElementById('status-filter-trigger');

      chipsContainer.innerHTML = '';

      if (selectedStatuses.size === 0) {
        clearAllBtn.style.display = 'none';
        statusTrigger.classList.remove('active');
      } else {
        clearAllBtn.style.display = 'inline-flex';
        statusTrigger.classList.add('active');

        selectedStatuses.forEach(status => {
          const chip = document.createElement('div');
          chip.className = `filter-chip ${status}`;

          const icon = document.createElement('span');
          icon.className = 'filter-chip-icon';
          icon.textContent = getStatusIcon(status);

          const label = document.createElement('span');
          label.textContent = getStatusLabel(status);

          const close = document.createElement('span');
          close.className = 'filter-chip-close';
          close.textContent = '‚úï';
          close.onclick = () => removeStatusFilter(status);

          chip.appendChild(icon);
          chip.appendChild(label);
          chip.appendChild(close);
          chipsContainer.appendChild(chip);
        });
      }

      updatePopoverCheckboxes();
    }

    // Get icon for status
    function getStatusIcon(status) {
      const icons = {
        'ready': '‚úì',
        'open': '‚óè',
        'in_progress': '‚óê',
        'closed': '‚úì',
        'blocked': '‚äò'
      };
      return icons[status] || '‚óè';
    }

    // Get display label for status
    function getStatusLabel(status) {
      const labels = {
        'ready': 'Ready',
        'open': 'Open',
        'in_progress': 'In Progress',
        'closed': 'Closed',
        'blocked': 'Blocked'
      };
      return labels[status] || status;
    }

    // Update popover checkbox states
    function updatePopoverCheckboxes() {
      document.querySelectorAll('.popover-option').forEach(option => {
        const status = option.dataset.status;
        const checkbox = option.querySelector('.popover-checkbox');
        if (selectedStatuses.has(status)) {
          checkbox.classList.add('checked');
        } else {
          checkbox.classList.remove('checked');
        }
      });
    }

    // Toggle status filter
    function toggleStatusFilter(status) {
      if (selectedStatuses.has(status)) {
        selectedStatuses.delete(status);
      } else {
        selectedStatuses.add(status);
      }
      updateFilterChips();
      renderTasks(allTasks);
    }

    // Remove specific status filter
    function removeStatusFilter(status) {
      selectedStatuses.delete(status);
      updateFilterChips();
      renderTasks(allTasks);
    }

    // Clear all filters
    function clearAllFilters() {
      selectedStatuses.clear();
      updateFilterChips();
      renderTasks(allTasks);
    }

    // Toggle popover
    function togglePopover() {
      const popover = document.getElementById('status-popover');
      isPopoverOpen = !isPopoverOpen;

      if (isPopoverOpen) {
        popover.classList.add('visible');
      } else {
        popover.classList.remove('visible');
      }
    }

    // Close popover when clicking outside
    document.addEventListener('click', (e) => {
      const trigger = document.getElementById('status-filter-trigger');
      const popover = document.getElementById('status-popover');

      if (!trigger.contains(e.target) && isPopoverOpen) {
        popover.classList.remove('visible');
        isPopoverOpen = false;
      }
    });

    // Function to render tasks
    function renderTasks(allTasks) {
      console.log('Rendering tasks:', allTasks.length, 'tasks');
      // If no statuses selected, show all tasks
      let filteredTasks;
      if (selectedStatuses.size === 0) {
        filteredTasks = allTasks;
      } else {
        const statusArray = Array.from(selectedStatuses);
        filteredTasks = allTasks.filter(task =>
          statusArray.includes(task.status) ||
          (statusArray.includes('ready') && task.status === 'open' && isReady(task, allTasks))
        );
      }
      const expandedTaskList = filteredTasks;
      const taskTree = buildTaskTree(expandedTaskList);

      const container = document.getElementById('task-container');
      container.innerHTML = '';

      // Create header table (fixed)
      const headerTable = document.createElement('table');
      headerTable.className = 'task-grid task-grid-header';

      // Add colgroup for consistent column widths
      const colgroup = document.createElement('colgroup');
      for (let i = 0; i < 6; i++) {
        const col = document.createElement('col');
        colgroup.appendChild(col);
      }
      headerTable.appendChild(colgroup);

      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const titleHeader = document.createElement('th');
      titleHeader.colSpan = 6;
      titleHeader.style.padding = '12px 16px';

      const headerContainer = document.createElement('div');
      headerContainer.className = 'header-single-row';

      const leftSection = document.createElement('div');
      leftSection.className = 'header-left';

      const filterIcon = document.createElement('span');
      filterIcon.innerHTML = '‚ñº';
      filterIcon.style.fontSize = '10px';
      filterIcon.style.opacity = '0.7';

      const titleText = document.createElement('span');
      titleText.textContent = 'Title';
      titleText.style.fontWeight = '600';

      leftSection.appendChild(filterIcon);
      leftSection.appendChild(titleText);

      const controlsSection = document.createElement('div');
      controlsSection.className = 'header-controls';

      const expandAllBtn = document.createElement('button');
      expandAllBtn.className = 'header-btn';
      expandAllBtn.textContent = 'Expand All';
      expandAllBtn.onclick = () => {
        expandedTasks.clear();
        allTasks.forEach(t => expandedTasks.add(t.id));
        renderTasks(allTasks);
      };

      const collapseAllBtn = document.createElement('button');
      collapseAllBtn.className = 'header-btn';
      collapseAllBtn.textContent = 'Collapse All';
      collapseAllBtn.onclick = () => {
        expandedTasks.clear();
        renderTasks(allTasks);
      };

      const createNewBtn = document.createElement('button');
      createNewBtn.className = 'create-new-issue-btn';
      createNewBtn.textContent = 'Create New Issue';
      createNewBtn.onclick = () => createNewTask();

      controlsSection.appendChild(expandAllBtn);
      controlsSection.appendChild(collapseAllBtn);
      controlsSection.appendChild(createNewBtn);

      headerContainer.appendChild(leftSection);
      headerContainer.appendChild(controlsSection);
      titleHeader.appendChild(headerContainer);

      headerRow.appendChild(titleHeader);

      thead.appendChild(headerRow);
      headerTable.appendChild(thead);
      container.appendChild(headerTable);

      // Create scrollable body container
      const bodyContainer = document.createElement('div');
      bodyContainer.className = 'task-body-container';

      // Create body table (scrollable)
      const bodyTable = document.createElement('table');
      bodyTable.className = 'task-grid task-grid-body';

      // Add colgroup for consistent column widths
      const bodyColgroup = document.createElement('colgroup');
      for (let i = 0; i < 6; i++) {
        const col = document.createElement('col');
        bodyColgroup.appendChild(col);
      }
      bodyTable.appendChild(bodyColgroup);

      const tbody = document.createElement('tbody');
      renderTaskTreeGrid(taskTree, tbody, allTasks);
      bodyTable.appendChild(tbody);

      bodyContainer.appendChild(bodyTable);
      container.appendChild(bodyContainer);

      // Render SVG tree lines after DOM is ready
      setTimeout(() => {
        renderTreeLinesSVG(bodyContainer, allTasks);
        updateScrollableHeight();
      }, 0);
    }

    // Function to build task hierarchy
    function buildTaskTree(tasks) {
      const taskMap = new Map();
      const roots = [];
      const hasParent = new Set();

      tasks.forEach(task => {
        taskMap.set(task.id, { ...task, children: [] });
      });

      tasks.forEach(task => {
        const node = taskMap.get(task.id);

        // Check for parent-child relationship
        const parentDep = (task.dependencies || []).find(dep => dep.type === 'parent-child');
        if (parentDep) {
          const parent = taskMap.get(parentDep.id);
          if (parent) {
            parent.children.push(node);
            hasParent.add(task.id);
          }
        }

        // Check for blocks relationship (task is blocked by another task)
        const blocksDep = (task.dependencies || []).find(dep => dep.type === 'blocks');
        if (blocksDep && !parentDep) { // Only if not already a child via parent-child
          const blocker = taskMap.get(blocksDep.id);
          if (blocker) {
            blocker.children.push(node);
            hasParent.add(task.id);
          }
        }
      });

      // Add all tasks without parents to roots
      tasks.forEach(task => {
        if (!hasParent.has(task.id)) {
          const node = taskMap.get(task.id);
          if (node) {
            roots.push(node);
          }
        }
      });

      return roots;
    }

    // Function to render task row for grid
    function renderTaskRowGrid(task, level = 0, allTasks, isLastChild = false, ancestorLines = []) {
      const hasChildren = task.children && task.children.length > 0;
      const isExpanded = expandedTasks.has(task.id);

      const tr = document.createElement('tr');
      tr.className = 'task-row';
      if (level > 0) tr.classList.add('child-row');

      // Title cell with expand/collapse
      const titleCell = document.createElement('td');
      
      // Store metadata for SVG line rendering
      tr.dataset.taskId = task.id;
      tr.dataset.level = level;
      tr.dataset.isLastChild = isLastChild;
      tr.dataset.hasChildren = hasChildren;

      const titleDiv = document.createElement('div');
      titleDiv.className = 'title-cell';
      titleDiv.style.paddingLeft = `${level * 30}px`;
      titleDiv.style.position = 'relative';
      titleDiv.style.zIndex = '2';

      // Expand/collapse icon
      const expandIcon = document.createElement('span');
      expandIcon.className = hasChildren ? (isExpanded ? 'expand-icon expanded' : 'expand-icon collapsed') : 'expand-icon empty';
      if (hasChildren) {
        expandIcon.onclick = () => toggleExpand(task.id);
      }
      titleDiv.appendChild(expandIcon);

      // Type badge
      const typeBadge = createTypeBadge(task.type);
      titleDiv.appendChild(typeBadge);

      // Title text
      const titleText = document.createElement('span');
      titleText.className = 'task-title-text';
      titleText.textContent = task.title;
      titleText.style.cursor = 'pointer';
      titleText.onclick = () => editTask(task.id);
      titleDiv.appendChild(titleText);

      titleCell.appendChild(titleDiv);
      tr.appendChild(titleCell);

      // Description cell
      const descriptionCell = document.createElement('td');
      descriptionCell.className = 'description-cell';
      const descriptionContent = document.createElement('div');
      const isDescExpanded = expandedDescriptions.has(task.id);

      if (task.description && task.description.trim()) {
        descriptionContent.className = `description-content ${isDescExpanded ? 'expanded' : 'collapsed'}`;
        if (isDescExpanded) {
          descriptionContent.innerHTML = markdownToHtml(task.description);
        } else {
          descriptionContent.textContent = task.description;
        }
        descriptionContent.onclick = () => toggleDescription(task.id);
        descriptionContent.title = isDescExpanded ? 'Click to collapse' : 'Click to expand';
      } else {
        descriptionContent.className = 'description-empty';
        descriptionContent.textContent = 'No description';
      }
      descriptionCell.appendChild(descriptionContent);
      tr.appendChild(descriptionCell);

      // Check if task is blocked
      const taskIsBlocked = isBlocked(task, allTasks);
      const displayStatus = taskIsBlocked ? 'blocked' : task.status;
      const displayText = taskIsBlocked ? 'Blocked' :
        (task.status === 'in_progress' ? 'In Progress' :
          (task.status.charAt(0).toUpperCase() + task.status.slice(1)));

      // Status cell
      const statusCell = document.createElement('td');
      const statusPill = createStatusPill(displayStatus, displayText);
      statusCell.appendChild(statusPill);
      tr.appendChild(statusCell);

      // Priority cell
      const priorityCell = document.createElement('td');
      const priorityPill = createPriorityPill(task.priority);
      priorityCell.appendChild(priorityPill);
      tr.appendChild(priorityCell);

      // Dependencies cell
      const dependencyCell = document.createElement('td');
      const blockers = (task.dependencies || []).filter(d => d.type === 'blocks').length;
      const blockedBy = allTasks.filter(t => t.dependencies?.some(d => d.id === task.id && d.type === 'blocks')).length;
      if (blockers > 0 || blockedBy > 0) {
        const depText = [];
        if (blockers > 0) depText.push(`${blockers}‚Üê`);
        if (blockedBy > 0) depText.push(`${blockedBy}‚Üí`);
        dependencyCell.textContent = depText.join(' ');
        dependencyCell.style.fontSize = '12px';
        dependencyCell.style.color = 'var(--vscode-descriptionForeground)';
        dependencyCell.style.textAlign = 'center';
      } else {
        dependencyCell.textContent = '';
      }
      tr.appendChild(dependencyCell);

      // Actions cell
      const actionsCell = document.createElement('td');
      actionsCell.className = 'task-actions';

      // Kebab menu button
      const kebabBtn = document.createElement('button');
      kebabBtn.className = 'kebab-menu-btn';
      kebabBtn.title = 'Actions';
      kebabBtn.innerHTML = '<div class="kebab-icon"><span></span><span></span><span></span></div>';
      kebabBtn.onclick = (e) => {
        e.stopPropagation();
        toggleActionDropdown(task.id, kebabBtn);
      };
      actionsCell.appendChild(kebabBtn);

      tr.appendChild(actionsCell);

      return tr;
    }

    // Function to render task tree for grid
    function renderTaskTreeGrid(tree, tbody, allTasks, level = 0, ancestorLines = []) {
      tree.forEach((node, index) => {
        const isLastChild = index === tree.length - 1;
        const tr = renderTaskRowGrid(node, level, allTasks, isLastChild, ancestorLines);
        tbody.appendChild(tr);

        // Check if there are hidden children at this level due to filtering (only if expanded)
        if (expandedTasks.has(node.id)) {
          const hiddenChildrenCount = countHiddenChildrenAtLevel(node, allTasks);
          if (hiddenChildrenCount > 0) {
            const hiddenRow = renderHiddenChildrenIndicator(hiddenChildrenCount, level + 1, isLastChild, [...ancestorLines, !isLastChild]);
            tbody.appendChild(hiddenRow);
          }
        }

        if (node.children && node.children.length > 0 && expandedTasks.has(node.id)) {
          // Pass down which levels should have continuing vertical lines
          const newAncestorLines = [...ancestorLines, !isLastChild];
          renderTaskTreeGrid(node.children, tbody, allTasks, level + 1, newAncestorLines);
        }
      });
    }

    // Function to count children that are hidden due to filtering at any level under this node
    function countHiddenChildrenAtLevel(parentNode, allTasks) {
      // Get all actual descendants from the full task list
      const allDescendants = getAllDescendants(parentNode.id, allTasks);

      // Get the IDs of descendants that are in the filtered tree (node.children is already filtered)
      const filteredDescendantIds = new Set();
      function collectFilteredIds(node) {
        if (node.children) {
          node.children.forEach(child => {
            filteredDescendantIds.add(child.id);
            collectFilteredIds(child);
          });
        }
      }
      collectFilteredIds(parentNode);

      // Count descendants that exist in allDescendants but NOT in the filtered tree
      // This means they were filtered out, not just collapsed
      const hiddenByFilter = allDescendants.filter(d => !filteredDescendantIds.has(d.id));
      return hiddenByFilter.length;
    }

    // Function to get all descendants of a task (recursive)
    function getAllDescendants(taskId, allTasks) {
      const descendants = [];
      const taskMap = new Map(allTasks.map(t => [t.id, t]));

      function collectDescendants(id) {
        allTasks.forEach(task => {
          const parentDep = (task.dependencies || []).find(dep => dep.type === 'parent-child');
          if (parentDep && parentDep.id === id) {
            descendants.push(task);
            collectDescendants(task.id);
          }
        });
      }

      collectDescendants(taskId);
      return descendants;
    }

    // Function to get descendants that are visible in the current filtered tree
    function getVisibleDescendantsInTree(node, allTasks) {
      const visible = [];

      function collectVisible(node) {
        if (node.children) {
          node.children.forEach(child => {
            visible.push(child);
            if (expandedTasks.has(child.id)) {
              collectVisible(child);
            }
          });
        }
      }

      collectVisible(node);
      return visible;
    }

    // Function to render a hidden children indicator row
    function renderHiddenChildrenIndicator(count, level, isLastChild, ancestorLines) {
      const tr = document.createElement('tr');
      tr.className = 'hidden-children-row';

      // Title cell with tree lines for hierarchy
      const titleCell = document.createElement('td');

      // Add tree lines for ancestor levels
      // Skip parent level to avoid overlap, but only for non-root items
      for (let ancestorLevel = 0; ancestorLevel < ancestorLines.length; ancestorLevel++) {
        if (level > 0 && ancestorLevel === level - 1) {
          // Skip parent level for non-root to avoid overlap
          continue;
        }
        if (ancestorLines[ancestorLevel]) {
          // This ancestor level has more siblings, draw a vertical line
          const ancestorLine = document.createElement('div');
          ancestorLine.className = 'tree-line tree-line-vertical';
          ancestorLine.style.left = `${ancestorLevel * 30 + 8 + 16}px`;
          titleCell.appendChild(ancestorLine);
        }
      }

      // Add vertical line only (no horizontal connection line)
      if (level > 0) {
        // Vertical line - full height for non-last children, corner for last child
        const vLine = document.createElement('div');
        if (isLastChild) {
          vLine.className = 'tree-line tree-line-corner';
        } else {
          vLine.className = 'tree-line tree-line-vertical';
        }
        vLine.style.left = `${(level - 1) * 30 + 8 + 16}px`;
        titleCell.appendChild(vLine);
      }

      const indicatorDiv = document.createElement('div');
      indicatorDiv.className = 'hidden-children-indicator';
      indicatorDiv.style.paddingLeft = `${level * 30 + 24}px`;
      indicatorDiv.style.position = 'relative';
      indicatorDiv.style.zIndex = '2';
      indicatorDiv.textContent = `${count} item${count === 1 ? '' : 's'} hidden by filter${count === 1 ? '' : 's'}`;
      titleCell.appendChild(indicatorDiv);

      tr.appendChild(titleCell);

      // Empty cells for other columns
      for (let i = 0; i < 5; i++) {
        const emptyCell = document.createElement('td');
        tr.appendChild(emptyCell);
      }

      return tr;
    }

    // Task interaction functions
    function startTask(id) {
      console.log('Starting task', id);
      vscode.postMessage({ type: 'startTask', id });
    }

    function completeTask(id) {
      console.log('Completing task', id);
      vscode.postMessage({ type: 'completeTask', id });
    }

    function editTask(id) {
      console.log('Editing task', id);
      console.log('vscode object:', vscode);
      console.log('typeof vscode.postMessage:', typeof vscode?.postMessage);
      try {
        const message = { type: 'editTicket', id };
        console.log('Attempting to post message:', message);
        vscode.postMessage(message);
        console.log('Message posted successfully');
      } catch (error) {
        console.error('Error posting message:', error);
      }
    }

    function createNewTask() {
      console.log('Creating new task');
      console.log('vscode object:', vscode);
      try {
        const message = { type: 'createTicket' };
        console.log('Attempting to post message:', message);
        vscode.postMessage(message);
        console.log('Message posted successfully');
      } catch (error) {
        console.error('Error posting message:', error);
      }
    }

    let deleteConfirmPopup = null;
    let activeActionDropdown = null;

    function toggleActionDropdown(taskId, button) {
      // Close any existing dropdown
      if (activeActionDropdown) {
        activeActionDropdown.remove();
        if (activeActionDropdown.taskId === taskId) {
          activeActionDropdown = null;
          button.classList.remove('active');
          return;
        }
        activeActionDropdown = null;
      }

      // Remove active state from all kebab buttons
      document.querySelectorAll('.kebab-menu-btn').forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');

      // Create dropdown
      const dropdown = document.createElement('div');
      dropdown.className = 'action-dropdown visible';
      dropdown.taskId = taskId;

      const task = allTasks.find(t => t.id === taskId);

      // Edit action
      const editItem = document.createElement('div');
      editItem.className = 'action-dropdown-item';
      editItem.innerHTML = `
        <div class="action-dropdown-icon">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M11 4H7.2C6.0799 4 5.51984 4 5.09202 4.21799C4.71569 4.40974 4.40973 4.7157 4.21799 5.09202C4 5.51985 4 6.0799 4 7.2V16.8C4 17.9201 4 18.4802 4.21799 18.908C4.40973 19.2843 4.71569 19.5903 5.09202 19.782C5.51984 20 6.0799 20 7.2 20H16.8C17.9201 20 18.4802 20 18.908 19.782C19.2843 19.5903 19.5903 19.2843 19.782 18.908C20 18.4802 20 17.9201 20 16.8V12.5M15.5 5.5L18.3284 8.32843M10.7627 10.2373L17.411 3.58902C18.192 2.80797 19.4584 2.80797 20.2394 3.58902C21.0205 4.37007 21.0205 5.6364 20.2394 6.41745L13.3774 13.2794C12.6158 14.0411 12.235 14.4219 11.8012 14.7247C11.4162 14.9936 11.0009 15.2162 10.564 15.3882C10.0717 15.582 9.54378 15.6885 8.48793 15.9016L8 16L8.04745 15.6678C8.21536 14.4925 8.29932 13.9048 8.49029 13.3561C8.65975 12.8692 8.89125 12.4063 9.17906 11.9786C9.50341 11.4966 9.92319 11.0768 10.7627 10.2373Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <span>Edit</span>
      `;
      editItem.onclick = () => {
        dropdown.remove();
        activeActionDropdown = null;
        button.classList.remove('active');
        editTask(taskId);
      };
      dropdown.appendChild(editItem);

      // Status progression actions
      if (task.status === 'open') {
        const startItem = document.createElement('div');
        startItem.className = 'action-dropdown-item';
        startItem.innerHTML = `
          <div class="action-dropdown-icon">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M8 5v14l11-7z" fill="currentColor"/>
            </svg>
          </div>
          <span>Start Task <span style="opacity: 0.6; font-size: 12px;">(Open ‚Üí In Progress)</span></span>
        `;
        startItem.onclick = () => {
          dropdown.remove();
          activeActionDropdown = null;
          button.classList.remove('active');
          startTask(taskId);
        };
        dropdown.appendChild(startItem);
      } else if (task.status === 'in_progress') {
        const completeItem = document.createElement('div');
        completeItem.className = 'action-dropdown-item';
        completeItem.innerHTML = `
          <div class="action-dropdown-icon">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <span>Complete Task <span style="opacity: 0.6; font-size: 12px;">(In Progress ‚Üí Closed)</span></span>
        `;
        completeItem.onclick = () => {
          dropdown.remove();
          activeActionDropdown = null;
          button.classList.remove('active');
          completeTask(taskId);
        };
        dropdown.appendChild(completeItem);
      }

      // Divider
      const divider = document.createElement('div');
      divider.className = 'action-dropdown-divider';
      dropdown.appendChild(divider);

      // Delete action
      const deleteItem = document.createElement('div');
      deleteItem.className = 'action-dropdown-item danger';
      deleteItem.innerHTML = `
        <div class="action-dropdown-icon">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L17.1991 18.0129C17.129 19.065 17.0939 19.5911 16.8667 19.99C16.6666 20.3412 16.3648 20.6235 16.0011 20.7998C15.588 21 15.0607 21 14.0062 21H9.99377C8.93927 21 8.41202 21 7.99889 20.7998C7.63517 20.6235 7.33339 20.3412 7.13332 19.99C6.90607 19.5911 6.871 19.065 6.80086 18.0129L6 6M4 6H20M16 6L15.7294 5.18807C15.4671 4.40125 15.3359 4.00784 15.0927 3.71698C14.8779 3.46013 14.6021 3.26132 14.2905 3.13878C13.9376 3 13.523 3 12.6936 3H11.3064C10.477 3 10.0624 3 9.70951 3.13878C9.39792 3.26132 9.12208 3.46013 8.90729 3.71698C8.66405 4.00784 8.53292 4.40125 8.27064 5.18807L8 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <span>Delete</span>
      `;
      deleteItem.onclick = (e) => {
        dropdown.remove();
        activeActionDropdown = null;
        button.classList.remove('active');
        showDeleteConfirmation(taskId, button);
      };
      dropdown.appendChild(deleteItem);

      // Position dropdown relative to button
      button.parentElement.appendChild(dropdown);
      activeActionDropdown = dropdown;

      // Close dropdown when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function closeDropdown(e) {
          if (dropdown && !dropdown.contains(e.target) && e.target !== button && !button.contains(e.target)) {
            dropdown.remove();
            activeActionDropdown = null;
            button.classList.remove('active');
            document.removeEventListener('click', closeDropdown);
          }
        });
      }, 0);
    }

    function showDeleteConfirmation(taskId, button) {
      // Close any existing popup
      if (deleteConfirmPopup) {
        deleteConfirmPopup.remove();
      }

      // Create popup
      const popup = document.createElement('div');
      popup.className = 'delete-confirm-popup visible';

      const task = allTasks.find(t => t.id === taskId);
      const childCount = task?.children?.length || 0;

      const textEl = document.createElement('div');
      textEl.className = 'delete-confirm-text';
      if (childCount > 0) {
        textEl.innerHTML = `Delete <strong>${task.title}</strong>?<br><br>This will unparent ${childCount} subtask${childCount === 1 ? '' : 's'}.`;
      } else {
        textEl.innerHTML = `Delete <strong>${task.title}</strong>?`;
      }

      const buttonsEl = document.createElement('div');
      buttonsEl.className = 'delete-confirm-buttons';

      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'delete-confirm-btn cancel';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = () => {
        popup.remove();
        deleteConfirmPopup = null;
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-confirm-btn delete';
      deleteBtn.textContent = 'Delete';
      deleteBtn.onclick = () => {
        popup.remove();
        deleteConfirmPopup = null;
        deleteTask(taskId);
      };

      buttonsEl.appendChild(cancelBtn);
      buttonsEl.appendChild(deleteBtn);

      popup.appendChild(textEl);
      popup.appendChild(buttonsEl);

      // Position popup relative to button
      document.body.appendChild(popup);
      const buttonRect = button.getBoundingClientRect();
      popup.style.position = 'fixed';
      popup.style.top = `${buttonRect.bottom + 4}px`;
      popup.style.left = `${buttonRect.left - popup.offsetWidth + button.offsetWidth}px`;

      deleteConfirmPopup = popup;

      // Close popup when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function closePopup(e) {
          if (popup && !popup.contains(e.target) && e.target !== button) {
            popup.remove();
            deleteConfirmPopup = null;
            document.removeEventListener('click', closePopup);
          }
        });
      }, 0);
    }

    function deleteTask(taskId) {
      console.log('Deleting task', taskId);
      vscode.postMessage({ type: 'deleteTask', id: taskId });
    }

    // Function to render tree lines using SVG overlay
    function renderTreeLinesSVG(container, allTasks) {
      // Remove existing SVG if present
      const existingSvg = container.querySelector('.tree-lines-svg');
      if (existingSvg) {
        existingSvg.remove();
      }

      // Get all task rows
      const rows = container.querySelectorAll('tr.task-row');
      if (rows.length === 0) return;

      // Create SVG element
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'tree-lines-svg');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '1';
      
      // Build a map of task positions
      const taskPositions = new Map();
      const containerRect = container.getBoundingClientRect();
      
      rows.forEach(row => {
        const taskId = row.dataset.taskId;
        const level = parseInt(row.dataset.level || '0');
        const isLastChild = row.dataset.isLastChild === 'true';
        const hasChildren = row.dataset.hasChildren === 'true';
        
        const rect = row.getBoundingClientRect();
        const relativeTop = rect.top - containerRect.top + container.scrollTop;
        const relativeBottom = rect.bottom - containerRect.top + container.scrollTop;
        const centerY = relativeTop + (rect.height / 2);
        
        taskPositions.set(taskId, {
          level,
          isLastChild,
          hasChildren,
          top: relativeTop,
          bottom: relativeBottom,
          centerY,
          height: rect.height
        });
      });
      
      // Build parent-child relationships
      const taskMap = new Map(allTasks.map(t => [t.id, t]));
      const childrenMap = new Map();
      
      allTasks.forEach(task => {
        const parentDep = (task.dependencies || []).find(dep => dep.type === 'parent-child');
        if (parentDep) {
          if (!childrenMap.has(parentDep.id)) {
            childrenMap.set(parentDep.id, []);
          }
          childrenMap.get(parentDep.id).push(task.id);
        }
        
        const blocksDep = (task.dependencies || []).find(dep => dep.type === 'blocks');
        if (blocksDep && !parentDep) {
          if (!childrenMap.has(blocksDep.id)) {
            childrenMap.set(blocksDep.id, []);
          }
          childrenMap.get(blocksDep.id).push(task.id);
        }
      });
      
      // Draw tree lines
      taskPositions.forEach((pos, taskId) => {
        const { level, isLastChild, hasChildren, centerY } = pos;
        // X position is at the center of the caret icon (16px wide)
        // With padding-left of level * 30, the caret center is at level * 30 + 8
        const x = level * 30 + 8 + 17; // +16 for cell padding
        
        // Draw connection to parent (horizontal line only)
        if (level > 0) {
          const parentX = (level - 1) * 30 + 8 + 18;
          
          // Horizontal line from parent's vertical line to this task's icon
          const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          hLine.setAttribute('x1', parentX);
          hLine.setAttribute('y1', centerY);
          hLine.setAttribute('x2', x - 8); // Stop 8px before caret center (at left edge of caret)
          hLine.setAttribute('y2', centerY);
          svg.appendChild(hLine);
        }
        
        // Draw vertical line to children if this task has expanded children
        if (hasChildren && expandedTasks.has(taskId)) {
          const children = childrenMap.get(taskId) || [];
          const visibleChildren = children.filter(childId => taskPositions.has(childId));
          
          if (visibleChildren.length > 0) {
            // Find the last visible child
            const lastChildId = visibleChildren[visibleChildren.length - 1];
            const lastChildPos = taskPositions.get(lastChildId);
            
            // Draw single vertical line from bottom of this task's caret to the last child's center
            // Caret is 16px tall, so bottom is at centerY + 8
            const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            vLine.setAttribute('x1', x);
            vLine.setAttribute('y1', centerY + 8);
            vLine.setAttribute('x2', x);
            vLine.setAttribute('y2', lastChildPos.centerY+1);
            svg.appendChild(vLine);
          }
        }
      });
      
      // Insert SVG at the beginning of container (behind content)
      container.insertBefore(svg, container.firstChild);
    }

    // Function to update scrollable container height
    function updateScrollableHeight() {
      requestAnimationFrame(() => {
        const bodyContainer = document.querySelector('.task-body-container');
        if (!bodyContainer) return;

        // Simply use the remaining viewport space
        const rect = bodyContainer.getBoundingClientRect();
        const availableHeight = window.innerHeight - rect.top;

        bodyContainer.style.height = `${Math.max(availableHeight, 200)}px`;
        bodyContainer.style.maxHeight = `${Math.max(availableHeight, 200)}px`;
      });
    }

    // Update height on load and resize
    window.addEventListener('load', updateScrollableHeight);
    window.addEventListener('resize', updateScrollableHeight);

    // Use ResizeObserver to handle layout changes (like window splits)
    const resizeObserver = new ResizeObserver(() => {
      updateScrollableHeight();
    });

    // Observe body for any size changes
    resizeObserver.observe(document.body);

    // Also observe the task container when it's created
    const observer = new MutationObserver(() => {
      const taskContainer = document.getElementById('task-container');
      if (taskContainer && !taskContainer.dataset.observed) {
        taskContainer.dataset.observed = 'true';
        resizeObserver.observe(taskContainer);
        updateScrollableHeight();
      }
    });

    observer.observe(document.body, { childList: true, subtree: true });

    // Listen for messages from extension
    window.addEventListener('message', event => {
      const message = event.data;
      console.log('Received message:', message);
      if (message.type === 'updateTasks') {
        console.log('Updating tasks:', message.tasks.length, 'tasks');
        allTasks = message.tasks;
        renderTasks(allTasks);
      }
    });

    // Add event listeners for filter UI
    document.getElementById('status-filter-trigger').addEventListener('click', (e) => {
      e.stopPropagation();
      togglePopover();
    });

    document.querySelectorAll('.popover-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation();
        const status = option.dataset.status;
        toggleStatusFilter(status);
      });
    });

    document.getElementById('clear-status-selection').addEventListener('click', (e) => {
      e.stopPropagation();
      selectedStatuses.clear();
      updateFilterChips();
      renderTasks(allTasks);
    });

    document.getElementById('clear-all-filters').addEventListener('click', () => {
      clearAllFilters();
    });

    document.getElementById('add-filter-btn').addEventListener('click', () => {
      // Placeholder for future filter options
      alert('Additional filters coming soon!\n\nFuture options:\n- Priority\n- Type\n- Assignee\n- Tags\n- Date ranges');
    });
  </script>
</body>

</html>