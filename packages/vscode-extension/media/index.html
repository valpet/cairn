<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Horizon Task List</title>
  <style>
    body {
      font-family: var(--vscode-font-family);
      font-size: var(--vscode-font-size);
      background-color: var(--vscode-sideBar-background);
      color: var(--vscode-foreground);
      margin: 0;
      padding: 20px;
    }

    h1 {
      color: #D4A556;
      font-size: 24px;
      margin: 0 0 20px 0;
    }

    .header {
      margin-bottom: 20px;
    }

    /* Filter Bar Styles */
    .filter-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 16px;
      padding: 8px 0;
      font-size: 13px;
    }

    .filter-icon {
      opacity: 0.5;
      font-size: 16px;
      margin-right: 2px;
      display: inline-flex;
      align-items: center;
    }

    .filter-icon svg {
      width: 16px;
      height: 16px;
    }

    .filter-trigger {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background-color: transparent;
      border: none;
      border-radius: 6px;
      color: var(--vscode-foreground);
      cursor: pointer;
      font-size: 13px;
      position: relative;
      transition: all 0.15s;
      font-weight: 400;
    }

    .filter-trigger:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .filter-trigger.active {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .filter-trigger-label {
      font-weight: 500;
      opacity: 0.9;
    }

    .filter-trigger-caret {
      opacity: 0.5;
      font-size: 10px;
      margin-left: 2px;
    }

    /* Filter Chips */
    .filter-chips {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .filter-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: default;
      transition: all 0.15s;
    }

    .filter-chip-icon {
      font-size: 14px;
      line-height: 1;
    }

    .filter-chip-close {
      cursor: pointer;
      opacity: 0.7;
      font-size: 16px;
      line-height: 1;
      padding: 0 0 0 4px;
      transition: opacity 0.15s;
    }

    .filter-chip-close:hover {
      opacity: 1;
    }

    /* Status-specific chip colors (muted versions) */
    .filter-chip.ready {
      background-color: rgba(212, 165, 86, 0.2);
      color: #D4A556;
    }

    .filter-chip.open {
      background-color: rgba(46, 160, 67, 0.2);
      color: #3fb950;
    }

    .filter-chip.in_progress {
      background-color: rgba(68, 131, 255, 0.2);
      color: #58a6ff;
    }

    .filter-chip.closed {
      background-color: rgba(139, 148, 158, 0.2);
      color: #8b949e;
    }

    .filter-chip.blocked {
      background-color: rgba(218, 54, 51, 0.2);
      color: #f85149;
    }

    /* Add Filter Button */
    .add-filter-btn {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 6px 10px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: #58a6ff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.15s;
    }

    .add-filter-btn:hover {
      background-color: rgba(88, 166, 255, 0.1);
    }

    .add-filter-btn-icon {
      font-size: 16px;
      line-height: 1;
    }

    /* Clear Filters Button */
    .clear-filters-btn {
      display: inline-flex;
      align-items: center;
      padding: 5px 10px;
      background: transparent;
      border: none;
      color: var(--vscode-foreground);
      cursor: pointer;
      font-size: 12px;
      opacity: 0.6;
      transition: opacity 0.15s;
      text-decoration: underline;
    }

    .clear-filters-btn:hover {
      opacity: 1;
    }

    /* Status Popover */
    .status-popover {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      min-width: 180px;
      background-color: var(--vscode-dropdown-background);
      border: 1px solid var(--vscode-dropdown-border);
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      padding: 6px 0;
      display: none;
    }

    .status-popover.visible {
      display: block;
    }

    .popover-header {
      padding: 8px 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      opacity: 0.6;
      letter-spacing: 0.5px;
    }

    .popover-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      transition: background-color 0.1s;
    }

    .popover-option:hover {
      background-color: var(--vscode-list-hoverBackground);
    }

    .popover-checkbox {
      width: 14px;
      height: 14px;
      border: 1.5px solid var(--vscode-input-border);
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.15s;
    }

    .popover-checkbox.checked {
      background-color: var(--vscode-button-background);
      border-color: var(--vscode-button-background);
    }

    .popover-checkbox.checked::after {
      content: '‚úì';
      color: var(--vscode-button-foreground);
      font-size: 10px;
      font-weight: bold;
    }

    .popover-divider {
      height: 1px;
      background-color: var(--vscode-dropdown-border);
      margin: 4px 0;
    }

    .popover-action {
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
      opacity: 0.8;
      transition: all 0.1s;
    }

    .popover-action:hover {
      background-color: var(--vscode-list-hoverBackground);
      opacity: 1;
    }

    .task-grid {
      width: 100%;
      border-collapse: collapse;
      background-color: var(--vscode-editor-background);
    }

    .task-grid th {
      background-color: var(--vscode-editor-background);
      color: var(--vscode-foreground);
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      border-bottom: 1px solid var(--vscode-panel-border);
      position: sticky;
      top: 0;
    }

    .header-controls {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    .header-btn {
      background-color: rgba(255, 255, 255, 0.05);
      color: var(--vscode-foreground);
      border: none;
      cursor: pointer;
      padding: 6px 12px;
      font-size: 13px;
      border-radius: 6px;
      font-weight: 400;
      transition: background-color 0.15s;
    }

    .header-btn:hover {
      background-color: rgba(255, 255, 255, 0.08);
    }

    .task-row {
      transition: background-color 0.1s;
    }

    .task-row:hover {
      background-color: var(--vscode-list-hoverBackground);
    }

    .title-cell {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .expand-icon {
      cursor: pointer;
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--vscode-foreground);
      opacity: 0.7;
      flex-shrink: 0;
      margin-left: 1px;
    }

    .expand-icon:hover {
      opacity: 1;
    }

    .expand-icon.collapsed::before {
      content: '‚ñ∂';
      font-size: 10px;
    }

    .expand-icon.expanded::before {
      content: '‚ñº';
      font-size: 10px;
    }

    .expand-icon.empty {
      opacity: 0;
      cursor: default;
    }

    .type-badge {
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
      height: 22px;
      line-height: 1;
    }

    .type-badge::before {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      line-height: 1;
    }

    .type-badge.epic {
      background-color: rgba(138, 98, 255, 0.2);
      color: #8A62FF;
    }

    .type-badge.epic::before {
      content: '‚ö°';
    }

    .type-badge.task {
      background-color: rgba(68, 131, 255, 0.2);
      color: #4483FF;
    }

    .type-badge.task::before {
      content: '‚Ä¢';
      font-size: 16px;
    }

    .type-badge.bug {
      background-color: rgba(218, 54, 51, 0.2);
      color: #f85149;
    }

    .type-badge.bug::before {
      content: 'üêõ';
      font-size: 11px;
    }

    .type-badge.feature {
      background-color: rgba(46, 160, 67, 0.2);
      color: #3fb950;
    }

    .type-badge.feature::before {
      content: '‚ú®';
      font-size: 11px;
    }

    .type-badge.chore {
      background-color: rgba(139, 148, 158, 0.2);
      color: #8b949e;
    }

    .type-badge.chore::before {
      content: 'üîß';
      font-size: 11px;
    }

    .type-badge.docs {
      background-color: rgba(88, 166, 255, 0.2);
      color: #58a6ff;
    }

    .type-badge.docs::before {
      content: 'üìù';
      font-size: 11px;
    }

    .type-badge.refactor {
      background-color: rgba(212, 165, 86, 0.2);
      color: #D4A556;
    }

    .type-badge.refactor::before {
      content: '‚ôªÔ∏è';
      font-size: 11px;
    }

    .task-title-text {
      color: var(--vscode-foreground);
    }

    .description-cell {
      max-width: 400px;
      position: relative;
    }

    .description-content {
      font-size: 12px;
      color: var(--vscode-descriptionForeground);
      line-height: 1.4;
    }

    .description-content.collapsed {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      cursor: pointer;
    }

    .description-content.collapsed:hover {
      color: var(--vscode-foreground);
    }

    .description-content.expanded {
      cursor: pointer;
    }

    .description-content.expanded h1,
    .description-content.expanded h2,
    .description-content.expanded h3 {
      margin: 8px 0 4px 0;
      color: var(--vscode-foreground);
    }

    .description-content.expanded h1 {
      font-size: 16px;
      font-weight: 600;
    }

    .description-content.expanded h2 {
      font-size: 14px;
      font-weight: 600;
    }

    .description-content.expanded h3 {
      font-size: 13px;
      font-weight: 600;
    }

    .description-content.expanded p {
      margin: 4px 0;
      line-height: 1.5;
    }

    .description-content.expanded ul,
    .description-content.expanded ol {
      margin: 4px 0;
      padding-left: 20px;
    }

    .description-content.expanded li {
      margin: 2px 0;
    }

    .description-content.expanded code {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: var(--vscode-editor-font-family);
      font-size: 0.9em;
    }

    .description-content.expanded pre {
      background-color: var(--vscode-textCodeBlock-background);
      padding: 8px;
      border-radius: 4px;
      overflow-x: auto;
      margin: 8px 0;
    }

    .description-content.expanded pre code {
      background: none;
      padding: 0;
    }

    .description-content.expanded strong {
      font-weight: 600;
      color: var(--vscode-foreground);
    }

    .description-content.expanded em {
      font-style: italic;
    }

    .description-empty {
      opacity: 0.4;
      font-style: italic;
      font-size: 12px;
    }

    .pill {
      padding: 6px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
      display: inline-block;
      text-transform: capitalize;
    }

    .status-open {
      background-color: rgba(46, 160, 67, 0.2);
      color: #3fb950;
    }

    .status-in_progress {
      background-color: rgba(68, 131, 255, 0.2);
      color: #58a6ff;
    }

    .status-closed {
      background-color: rgba(139, 148, 158, 0.2);
      color: #8b949e;
    }

    .status-blocked {
      background-color: rgba(218, 54, 51, 0.2);
      color: #f85149;
    }

    .priority-low {
      background-color: rgba(46, 160, 67, 0.2);
      color: #3fb950;
    }

    .priority-medium {
      background-color: rgba(212, 165, 86, 0.2);
      color: #D4A556;
    }

    .priority-high {
      background-color: rgba(251, 133, 0, 0.2);
      color: #fb8500;
    }

    .priority-urgent {
      background-color: rgba(218, 54, 51, 0.2);
      color: #f85149;
    }

    .task-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-start;
    }

    .start-btn {
      background-color: #0969da;
      color: white;
      border: none;
      padding: 6px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
    }

    .start-btn:hover {
      background-color: #0860ca;
    }

    .complete-btn {
      background-color: #2ea043;
      color: white;
      border: none;
      padding: 6px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
    }

    .complete-btn:hover {
      background-color: #2c974b;
    }

    .child-row {
      background-color: var(--vscode-editor-background);
    }

    .title-cell {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 100%;
    }

    .task-grid td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--vscode-panel-border);
      vertical-align: top;
      position: relative;
    }

    .tree-line {
      position: absolute;
      background-color: rgba(255, 255, 255, 0.15);
      pointer-events: none;
      z-index: 1;
    }

    .tree-line-vertical {
      width: 2px;
      top: 0;
      bottom: 0;
    }

    .tree-line-horizontal {
      height: 2px;
      width: 20px;
      left: 2px;
      top: 26px;
    }

    .tree-line-corner {
      width: 2px;
      top: 0;
      height: 26px;
    }

    /* Vertical line from parent to children */
    .tree-line-parent-vertical {
      width: 2px;
      top: 36px;
      bottom: 0;
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>Horizon Task List</h1>
  </div>
  <div class="filter-bar">
    <div class="filter-trigger" id="status-filter-trigger">
      <span class="filter-icon"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M19 3H5C3.58579 3 2.87868 3 2.43934 3.4122C2 3.8244 2 4.48782 2 5.81466V6.50448C2 7.54232 2 8.06124 2.2596 8.49142C2.5192 8.9216 2.99347 9.18858 3.94202 9.72255L6.85504 11.3624C7.49146 11.7206 7.80967 11.8998 8.03751 12.0976C8.51199 12.5095 8.80408 12.9935 8.93644 13.5872C9 13.8722 9 14.2058 9 14.8729L9 17.5424C9 18.452 9 18.9067 9.25192 19.2613C9.50385 19.6158 9.95128 19.7907 10.8462 20.1406C12.7248 20.875 13.6641 21.2422 14.3321 20.8244C15 20.4066 15 19.4519 15 17.5424V14.8729C15 14.2058 15 13.8722 15.0636 13.5872C15.1959 12.9935 15.488 12.5095 15.9625 12.0976C16.1903 11.8998 16.5085 11.7206 17.145 11.3624L20.058 9.72255C21.0065 9.18858 21.4808 8.9216 21.7404 8.49142C22 8.06124 22 7.54232 22 6.50448V5.81466C22 4.48782 22 3.8244 21.5607 3.4122C21.1213 3 20.4142 3 19 3Z"
            fill="currentColor"></path>
        </svg></span>
      <span class="filter-trigger-label">Status:</span>
      <div class="status-popover" id="status-popover">
        <div class="popover-header">Status</div>
        <div class="popover-option" data-status="ready">
          <div class="popover-checkbox"></div>
          <span>Ready</span>
        </div>
        <div class="popover-option" data-status="open">
          <div class="popover-checkbox"></div>
          <span>Open</span>
        </div>
        <div class="popover-option" data-status="in_progress">
          <div class="popover-checkbox"></div>
          <span>In Progress</span>
        </div>
        <div class="popover-option" data-status="closed">
          <div class="popover-checkbox"></div>
          <span>Closed</span>
        </div>
        <div class="popover-option" data-status="blocked">
          <div class="popover-checkbox"></div>
          <span>Blocked</span>
        </div>
        <div class="popover-divider"></div>
        <div class="popover-action" id="clear-status-selection">Clear</div>
      </div>
    </div>
    <div class="filter-chips" id="filter-chips"></div>
    <button class="clear-filters-btn" id="clear-all-filters" style="display: none;">Clear filters</button>
    <button class="add-filter-btn" id="add-filter-btn">
      <span class="add-filter-btn-icon">+</span>
      <span>Add Filter</span>
    </button>
  </div>
  <div id="task-container">
    <!-- Tasks will be populated here -->
  </div>

  <script>
    const expandedTasks = new Set();
    const expandedDescriptions = new Set();
    let selectedStatuses = new Set(['ready']); // Default filter
    let isPopoverOpen = false;

    // Simple markdown to HTML converter
    function markdownToHtml(markdown) {
      let html = markdown;

      // Code blocks (before inline code)
      html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');

      // Headers
      html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
      html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
      html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');

      // Bold
      html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

      // Italic
      html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');

      // Inline code
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

      // Unordered lists
      html = html.replace(/^- (.+)$/gim, '<li>$1</li>');
      html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');

      // Paragraphs (split by double newlines)
      const parts = html.split('\n\n');
      html = parts.map(part => {
        part = part.trim();
        if (!part) return '';
        if (part.startsWith('<h') || part.startsWith('<ul') || part.startsWith('<pre')) {
          return part;
        }
        return '<p>' + part.replace(/\n/g, '<br>') + '</p>';
      }).join('\n');

      return html;
    }

    // Function to check if a task is ready (no blocking dependencies)
    function isReady(task, allTasks) {
      if (!task.dependencies) return true;
      const taskMap = new Map(allTasks.map(t => [t.id, t]));
      return task.dependencies.every(dep => {
        if (dep.type !== 'blocks') return true;
        const depTask = taskMap.get(dep.id);
        return depTask && depTask.status === 'closed';
      });
    }

    // Function to check if a task is blocked
    function isBlocked(task, allTasks) {
      if (!task.dependencies || task.status === 'closed') return false;
      const taskMap = new Map(allTasks.map(t => [t.id, t]));
      return task.dependencies.some(dep => {
        if (dep.type !== 'blocks') return false;
        const depTask = taskMap.get(dep.id);
        return depTask && depTask.status !== 'closed';
      });
    }

    function toggleExpand(taskId) {
      if (expandedTasks.has(taskId)) {
        expandedTasks.delete(taskId);
      } else {
        expandedTasks.add(taskId);
      }
      renderTasks(allTasks);
    }

    function toggleDescription(taskId) {
      if (expandedDescriptions.has(taskId)) {
        expandedDescriptions.delete(taskId);
      } else {
        expandedDescriptions.add(taskId);
      }
      renderTasks(allTasks);
    }

    // Update filter chips display
    function updateFilterChips() {
      const chipsContainer = document.getElementById('filter-chips');
      const clearAllBtn = document.getElementById('clear-all-filters');
      const statusTrigger = document.getElementById('status-filter-trigger');

      chipsContainer.innerHTML = '';

      if (selectedStatuses.size === 0) {
        clearAllBtn.style.display = 'none';
        statusTrigger.classList.remove('active');
      } else {
        clearAllBtn.style.display = 'inline-flex';
        statusTrigger.classList.add('active');

        selectedStatuses.forEach(status => {
          const chip = document.createElement('div');
          chip.className = `filter-chip ${status}`;

          const icon = document.createElement('span');
          icon.className = 'filter-chip-icon';
          icon.textContent = getStatusIcon(status);

          const label = document.createElement('span');
          label.textContent = getStatusLabel(status);

          const close = document.createElement('span');
          close.className = 'filter-chip-close';
          close.textContent = '‚úï';
          close.onclick = () => removeStatusFilter(status);

          chip.appendChild(icon);
          chip.appendChild(label);
          chip.appendChild(close);
          chipsContainer.appendChild(chip);
        });
      }

      updatePopoverCheckboxes();
    }

    // Get icon for status
    function getStatusIcon(status) {
      const icons = {
        'ready': '‚úì',
        'open': '‚óè',
        'in_progress': '‚óê',
        'closed': '‚úì',
        'blocked': '‚äò'
      };
      return icons[status] || '‚óè';
    }

    // Get display label for status
    function getStatusLabel(status) {
      const labels = {
        'ready': 'Ready',
        'open': 'Open',
        'in_progress': 'In Progress',
        'closed': 'Closed',
        'blocked': 'Blocked'
      };
      return labels[status] || status;
    }

    // Update popover checkbox states
    function updatePopoverCheckboxes() {
      document.querySelectorAll('.popover-option').forEach(option => {
        const status = option.dataset.status;
        const checkbox = option.querySelector('.popover-checkbox');
        if (selectedStatuses.has(status)) {
          checkbox.classList.add('checked');
        } else {
          checkbox.classList.remove('checked');
        }
      });
    }

    // Toggle status filter
    function toggleStatusFilter(status) {
      if (selectedStatuses.has(status)) {
        selectedStatuses.delete(status);
      } else {
        selectedStatuses.add(status);
      }
      updateFilterChips();
      renderTasks(allTasks);
    }

    // Remove specific status filter
    function removeStatusFilter(status) {
      selectedStatuses.delete(status);
      updateFilterChips();
      renderTasks(allTasks);
    }

    // Clear all filters
    function clearAllFilters() {
      selectedStatuses.clear();
      updateFilterChips();
      renderTasks(allTasks);
    }

    // Toggle popover
    function togglePopover() {
      const popover = document.getElementById('status-popover');
      isPopoverOpen = !isPopoverOpen;

      if (isPopoverOpen) {
        popover.classList.add('visible');
      } else {
        popover.classList.remove('visible');
      }
    }

    // Close popover when clicking outside
    document.addEventListener('click', (e) => {
      const trigger = document.getElementById('status-filter-trigger');
      const popover = document.getElementById('status-popover');

      if (!trigger.contains(e.target) && isPopoverOpen) {
        popover.classList.remove('visible');
        isPopoverOpen = false;
      }
    });

    // Function to render tasks
    function renderTasks(allTasks) {
      // If no statuses selected, show all tasks
      let filteredTasks;
      if (selectedStatuses.size === 0) {
        filteredTasks = allTasks;
      } else {
        const statusArray = Array.from(selectedStatuses);
        filteredTasks = allTasks.filter(task =>
          statusArray.includes(task.status) ||
          (statusArray.includes('ready') && task.status === 'open' && isReady(task, allTasks))
        );
      }
      const expandedTaskList = filteredTasks;
      const taskTree = buildTaskTree(expandedTaskList);

      const container = document.getElementById('task-container');
      container.innerHTML = '';

      const table = document.createElement('table');
      table.className = 'task-grid';
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      const titleHeader = document.createElement('th');
      titleHeader.style.display = 'flex';
      titleHeader.style.alignItems = 'center';
      titleHeader.style.justifyContent = 'space-between';

      const titleSection = document.createElement('div');
      titleSection.style.display = 'flex';
      titleSection.style.alignItems = 'center';
      titleSection.style.gap = '10px';

      const filterIcon = document.createElement('span');
      filterIcon.innerHTML = '‚ñº';
      filterIcon.style.fontSize = '10px';

      const titleText = document.createElement('span');
      titleText.textContent = 'Title';

      titleSection.appendChild(filterIcon);
      titleSection.appendChild(titleText);

      const controlsSection = document.createElement('div');
      controlsSection.className = 'header-controls';

      const expandAllBtn = document.createElement('button');
      expandAllBtn.className = 'header-btn';
      expandAllBtn.textContent = 'Expand All';
      expandAllBtn.onclick = () => {
        expandedTasks.clear();
        allTasks.forEach(t => expandedTasks.add(t.id));
        renderTasks(allTasks);
      };

      const collapseAllBtn = document.createElement('button');
      collapseAllBtn.className = 'header-btn';
      collapseAllBtn.textContent = 'Collapse All';
      collapseAllBtn.onclick = () => {
        expandedTasks.clear();
        renderTasks(allTasks);
      };

      controlsSection.appendChild(expandAllBtn);
      controlsSection.appendChild(collapseAllBtn);

      titleHeader.appendChild(titleSection);
      titleHeader.appendChild(controlsSection);

      headerRow.appendChild(titleHeader);

      ['Description', 'Status', 'Priority', 'Actions'].forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        headerRow.appendChild(th);
      });

      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      renderTaskTreeGrid(taskTree, tbody, allTasks);
      table.appendChild(tbody);

      container.appendChild(table);
    }

    // Function to build task hierarchy
    function buildTaskTree(tasks) {
      const taskMap = new Map();
      const roots = [];
      const hasParent = new Set();

      tasks.forEach(task => {
        taskMap.set(task.id, { ...task, children: [] });
      });

      tasks.forEach(task => {
        const node = taskMap.get(task.id);

        // Check for parent-child relationship
        const parentDep = (task.dependencies || []).find(dep => dep.type === 'parent-child');
        if (parentDep) {
          const parent = taskMap.get(parentDep.id);
          if (parent) {
            parent.children.push(node);
            hasParent.add(task.id);
          }
        }

        // Check for blocks relationship (task is blocked by another task)
        const blocksDep = (task.dependencies || []).find(dep => dep.type === 'blocks');
        if (blocksDep && !parentDep) { // Only if not already a child via parent-child
          const blocker = taskMap.get(blocksDep.id);
          if (blocker) {
            blocker.children.push(node);
            hasParent.add(task.id);
          }
        }
      });

      // Add all tasks without parents to roots
      tasks.forEach(task => {
        if (!hasParent.has(task.id)) {
          const node = taskMap.get(task.id);
          if (node) {
            roots.push(node);
          }
        }
      });

      return roots;
    }

    // Function to render task row for grid
    function renderTaskRowGrid(task, level = 0, allTasks, isLastChild = false, ancestorLines = []) {
      const hasChildren = task.children && task.children.length > 0;
      const isExpanded = expandedTasks.has(task.id);

      const tr = document.createElement('tr');
      tr.className = 'task-row';
      if (level > 0) tr.classList.add('child-row');

      // Title cell with expand/collapse
      const titleCell = document.createElement('td');

      // Add tree lines for ancestor levels (exclude immediate parent level to avoid overlap)
      // Only draw for levels 0 to level-2, as level-1 is handled by our own connection
      const maxAncestorLevel = Math.min(ancestorLines.length, level - 1);
      for (let ancestorLevel = 0; ancestorLevel < maxAncestorLevel; ancestorLevel++) {
        if (ancestorLines[ancestorLevel]) {
          // This ancestor level has more siblings, draw a vertical line
          const ancestorLine = document.createElement('div');
          ancestorLine.className = 'tree-line tree-line-vertical';
          ancestorLine.style.left = `${ancestorLevel * 30 + 8 + 16}px`;
          titleCell.appendChild(ancestorLine);
        }
      }

      // Add tree lines for child nodes (position relative to TD)
      if (level > 0) {
        // Horizontal line
        const hLine = document.createElement('div');
        hLine.className = 'tree-line tree-line-horizontal';
        hLine.style.left = `${(level - 1) * 30 + 8 + 16}px`;
        titleCell.appendChild(hLine);

        // Vertical line - full height for non-last children, corner for last child
        const vLine = document.createElement('div');
        if (isLastChild) {
          vLine.className = 'tree-line tree-line-corner';
        } else {
          vLine.className = 'tree-line tree-line-vertical';
        }
        vLine.style.left = `${(level - 1) * 30 + 8 + 16}px`;
        titleCell.appendChild(vLine);
      }

      const titleDiv = document.createElement('div');
      titleDiv.className = 'title-cell';
      titleDiv.style.paddingLeft = `${level * 30}px`;
      titleDiv.style.position = 'relative';
      titleDiv.style.zIndex = '2';

      // If this task has children, add a vertical line extending down from it
      if (hasChildren && isExpanded) {
        const parentLine = document.createElement('div');
        parentLine.className = 'tree-line tree-line-parent-vertical';
        parentLine.style.left = `${level * 30 + 8 + 16}px`;
        titleCell.appendChild(parentLine);
      }

      // Expand/collapse icon
      const expandIcon = document.createElement('span');
      expandIcon.className = hasChildren ? (isExpanded ? 'expand-icon expanded' : 'expand-icon collapsed') : 'expand-icon empty';
      if (hasChildren) {
        expandIcon.onclick = () => toggleExpand(task.id);
      }
      titleDiv.appendChild(expandIcon);

      // Type badge
      const typeBadge = document.createElement('span');
      typeBadge.className = `type-badge ${task.type || 'task'}`;
      typeBadge.textContent = task.type || 'Task';
      titleDiv.appendChild(typeBadge);

      // Title text
      const titleText = document.createElement('span');
      titleText.className = 'task-title-text';
      titleText.textContent = task.title;
      titleDiv.appendChild(titleText);

      titleCell.appendChild(titleDiv);
      tr.appendChild(titleCell);

      // Description cell
      const descriptionCell = document.createElement('td');
      descriptionCell.className = 'description-cell';
      const descriptionContent = document.createElement('div');
      const isDescExpanded = expandedDescriptions.has(task.id);

      if (task.description && task.description.trim()) {
        descriptionContent.className = `description-content ${isDescExpanded ? 'expanded' : 'collapsed'}`;
        if (isDescExpanded) {
          descriptionContent.innerHTML = markdownToHtml(task.description);
        } else {
          descriptionContent.textContent = task.description;
        }
        descriptionContent.onclick = () => toggleDescription(task.id);
        descriptionContent.title = isDescExpanded ? 'Click to collapse' : 'Click to expand';
      } else {
        descriptionContent.className = 'description-empty';
        descriptionContent.textContent = 'No description';
      }
      descriptionCell.appendChild(descriptionContent);
      tr.appendChild(descriptionCell);

      // Status cell
      const statusCell = document.createElement('td');
      const statusPill = document.createElement('span');

      // Check if task is blocked
      const taskIsBlocked = isBlocked(task, allTasks);
      const displayStatus = taskIsBlocked ? 'blocked' : task.status;
      const displayText = taskIsBlocked ? 'Blocked' :
        (task.status === 'in_progress' ? 'In Progress' :
          (task.status.charAt(0).toUpperCase() + task.status.slice(1)));

      statusPill.className = `pill status-${displayStatus}`;
      statusPill.textContent = displayText;
      statusCell.appendChild(statusPill);
      tr.appendChild(statusCell);

      // Priority cell
      const priorityCell = document.createElement('td');
      const priorityPill = document.createElement('span');
      priorityPill.className = `pill priority-${task.priority}`;
      priorityPill.textContent = task.priority.charAt(0).toUpperCase() + task.priority.slice(1);
      priorityCell.appendChild(priorityPill);
      tr.appendChild(priorityCell);

      // Actions cell
      const actionsCell = document.createElement('td');
      actionsCell.className = 'task-actions';
      if (task.status === 'open') {
        const startBtn = document.createElement('button');
        startBtn.className = 'start-btn';
        startBtn.textContent = 'Start';
        startBtn.onclick = () => startTask(task.id);
        actionsCell.appendChild(startBtn);
      } else if (task.status === 'in_progress') {
        const completeBtn = document.createElement('button');
        completeBtn.className = 'complete-btn';
        completeBtn.textContent = 'Complete';
        completeBtn.onclick = () => completeTask(task.id);
        actionsCell.appendChild(completeBtn);
      }
      tr.appendChild(actionsCell);

      return tr;
    }

    // Function to render task tree for grid
    function renderTaskTreeGrid(tree, tbody, allTasks, level = 0, ancestorLines = []) {
      tree.forEach((node, index) => {
        const isLastChild = index === tree.length - 1;
        const tr = renderTaskRowGrid(node, level, allTasks, isLastChild, ancestorLines);
        tbody.appendChild(tr);
        if (node.children && node.children.length > 0 && expandedTasks.has(node.id)) {
          // Pass down which levels should have continuing vertical lines
          const newAncestorLines = [...ancestorLines, !isLastChild];
          renderTaskTreeGrid(node.children, tbody, allTasks, level + 1, newAncestorLines);
        }
      });
    }

    // Task interaction functions
    function startTask(id) {
      window.vscode = window.vscode || acquireVsCodeApi();
      vscode.postMessage({ type: 'startTask', id });
    }

    function completeTask(id) {
      window.vscode = window.vscode || acquireVsCodeApi();
      vscode.postMessage({ type: 'completeTask', id });
    }

    // Initial render (will be updated via message)
    let allTasks = [];
    updateFilterChips();
    renderTasks([]);

    // Listen for messages from extension
    window.addEventListener('message', event => {
      const message = event.data;
      if (message.type === 'updateTasks') {
        allTasks = message.tasks;
        renderTasks(allTasks);
      }
    });

    // Add event listeners for filter UI
    document.getElementById('status-filter-trigger').addEventListener('click', (e) => {
      e.stopPropagation();
      togglePopover();
    });

    document.querySelectorAll('.popover-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation();
        const status = option.dataset.status;
        toggleStatusFilter(status);
      });
    });

    document.getElementById('clear-status-selection').addEventListener('click', (e) => {
      e.stopPropagation();
      selectedStatuses.clear();
      updateFilterChips();
      renderTasks(allTasks);
    });

    document.getElementById('clear-all-filters').addEventListener('click', () => {
      clearAllFilters();
    });

    document.getElementById('add-filter-btn').addEventListener('click', () => {
      // Placeholder for future filter options
      alert('Additional filters coming soon!\n\nFuture options:\n- Priority\n- Type\n- Assignee\n- Tags\n- Date ranges');
    });
  </script>
</body>

</html>